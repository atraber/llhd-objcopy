extern crate llhd;

use std::error::Error;
use std::io::prelude::*;
use std::fs::File;
use std::path::Path;

use vlog::module::*;

struct VlogWriter {
	modules: Vec<Module>,
	instances: Vec<Instance>,
	instance_counter : usize,
}

impl VlogWriter {
	fn new () -> VlogWriter {
		VlogWriter {
			modules: vec![],
			instances: vec![],
			instance_counter: 0,
		}
	}

	fn inst_name(&mut self, inst: &llhd::value::Value) -> String {
		match inst.name() {
			Some(s) => s.to_string(),
			None => {
				self.instance_counter += 1;
				format!("i_{}", self.instance_counter)
			},
		}
	}

	fn module_push(&mut self, m : Module) -> ModuleRef {
		// TODO: we should check if the module name is unique
		let id = self.modules.len();

		self.modules.push(m);

		let mut m = self.modules.get_mut(id).unwrap();
		m.id = id;
		return ModuleRef::new(m);
	}

	fn module_get(&self, name : String) -> Option<ModuleRef> {
		// TODO: this should be done more efficient, e.g. hash map as this is
		// currently O(n)
		for m in &self.modules {
			if m.name == name {
				return Some(ModuleRef::new(m));
			}
		}

		return None;
	}

	fn module(&self, m_ref : &ModuleRef) -> Option<&Module> {
		self.modules.get(m_ref.id)
	}

	fn module_mut(&mut self, m_ref : &ModuleRef) -> Option<&mut Module> {
		self.modules.get_mut(m_ref.id)
	}

	fn instance(&self, i_ref : &InstanceRef) -> Option<&Instance> {
		self.instances.get(i_ref.id)
	}

	fn instance_mut(&mut self, i_ref : &InstanceRef) -> Option<&mut Instance> {
		self.instances.get_mut(i_ref.id)
	}

	fn process_entity(&mut self, module : &llhd::Module, entity: &llhd::Entity) -> () {
		let m_ref = self.module_push(Module::new(entity.name().to_string()));
		let mut m = self.module_mut(&m_ref).unwrap();

		for inst in entity.insts() {
			match inst.kind() {
				&llhd::inst::InstKind::InstanceInst(_, ref target, ref ins, ref outs) => {
					match target {
						&llhd::value::ValueRef::Entity(e) => {
							println!("{:?}", e);
							let en = module.entity(e);
							let inst_mod = match self.module_get(en.name().to_string()) {
								Some(im) => {
									im
								}
								None => {
									panic!("Did not find module {:?}", en.name())
								}
							};

							let inst_name = self.inst_name(inst);
							m.instances.push(Instance::new(
								inst_name,
								inst_mod));
						},
						_ => panic!("Not an entity"),
					}
				},
				_ => println!("Not supported"),
			}
		}
	}

	fn from_llhd(&mut self, module : llhd::Module) -> () {
		for value in module.values() {
			match value {
				&llhd::ValueRef::Entity(e) => {
					let entity = module.entity(e);
					self.process_entity(&module, entity);
				},
				_ => println!("Something else"),
			}
		}
	}

	fn write_ports(&self, mut file : &File, m : &Module) {
		for port in &m.ports {
			write!(file, "port\n");
		}
	}

	fn write_wires(&self, mut file : &File, m : &Module) {
		for wire in &m.wires {
			write!(file, "wire\n");
		}
	}

	fn write_instances(&self, mut file : &File, m : &Module) {
		for i in &m.instances {
			let m = self.module(&i.module).unwrap();
			write!(file, "  {} {} (\n", m.name, i.inst_name);
			write!(file, "  );\n");
		}
	}

	fn write_assigns(&self, mut file : &File, m : &Module) {
		for assign in &m.assigns {
			write!(file, "assign\n");
		}
	}

	fn write(&self, filepath : &Path) -> () {
		let mut file = match File::create(&filepath) {
			Err(err) => panic!("Could not create {:?}: {}", filepath, err.description()),
			Ok(f) => f,
		};

		file.write(b"// This file was generated by llhd-objcopy\n\n");

		for m in &self.modules {
			println!("{:?}", m);
			if m.ports.len() > 0 {
				write!(file, "module {}(\n", m.name);
				self.write_ports(&file, m);
				write!(file, "  );\n");
			} else {
				write!(file, "module {};\n", m.name);
			}

			self.write_wires(&file, m);
			self.write_instances(&file, m);
			self.write_assigns(&file, m);
			write!(file, "endmodule\n\n");
		}
	}
}

pub fn write(filepath : &Path, module : llhd::Module) {
	let mut vlog_writer = VlogWriter::new();
	vlog_writer.from_llhd(module);
	vlog_writer.write(filepath);
}